# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import time
import uuid
import random
import hashlib
import logging
from os.path import join, exists, dirname

from sugar_network.toolkit import Option, util, enforce


_XO_SERIAL_PATH = '/ofw/mfg-data/SN'
_XO_UUID_PATH = '/ofw/mfg-data/U#'
_NICKNAME_GCONF = '/desktop/sugar/user/nick'
_COLOR_GCONF = '/desktop/sugar/user/color'

_logger = logging.getLogger('sugar')
_uid = None


keyfile = Option(
        'path to SSH private key file to authenticate user; public key file '
        'should have ".pub" suffif; if ommited, use key file generated by '
        'Sugar Shell',
        name='keyfile')


def logger_level():
    """Current Sugar logger level as --debug value."""
    _LEVELS = {
            'error': 0,
            'warning': 0,
            'info': 1,
            'debug': 2,
            'all': 2,
            }
    level = os.environ.get('SUGAR_LOGGER_LEVEL')
    return _LEVELS.get(level, 0)


def profile_path(*args):
    """Path within sugar profile directory.

    Missed directories will be created.

    :param args:
        path parts that will be added to the resulting path
    :returns:
        full path with directory part existed

    """
    if os.geteuid():
        root_dir = join(os.environ['HOME'], '.sugar',
                os.environ.get('SUGAR_PROFILE', 'default'))
    else:
        root_dir = '/var/sugar-network'
    return join(root_dir, *args)


def ensure_key(path=None):
    if path is None:
        path = keyfile.value
    if not path:
        path = profile_path('owner.key')
    keyfile.value = path

    if not exists(path):
        if not exists(dirname(path)):
            os.makedirs(dirname(path))
        _logger.info('Create DSA key')
        util.assert_call([
            '/usr/bin/ssh-keygen', '-q', '-t', 'dsa', '-f', path,
            '-C', '', '-N', ''])

    with file(path + '.pub') as f:
        for line in f:
            line = line.strip()
            if line.startswith('ssh-'):
                key = line.split()[1]
                return str(hashlib.sha1(key).hexdigest())

    raise RuntimeError('No valid DSA public key in %r' % path)


def pubkey():
    pubkey_path = keyfile.value + '.pub'
    enforce(exists(pubkey_path),
            'Sugar session was never started, no privkey')
    with file(pubkey_path) as f:
        for line in f.readlines():
            line = line.strip()
            if line.startswith('ssh-'):
                return line
    raise RuntimeError('Valid SSH public key was not found in %s' %
            pubkey_path)


def uid():
    global _uid

    if _uid is None:
        key = pubkey().split()[1]
        _uid = str(hashlib.sha1(key).hexdigest())

    return _uid


def nickname():
    import gconf
    gconf_client = gconf.client_get_default()
    return gconf_client.get_string(_NICKNAME_GCONF)


def color():
    import gconf
    gconf_client = gconf.client_get_default()
    return gconf_client.get_string(_COLOR_GCONF)


def machine_sn():
    if exists(_XO_SERIAL_PATH):
        return _read_XO_value(_XO_SERIAL_PATH)


def machine_uuid():
    if exists(_XO_UUID_PATH):
        return _read_XO_value(_XO_UUID_PATH)


def uuid_new():
    data = '%s%s%s' % \
            (time.time(), random.randint(10000, 100000), uuid.getnode())
    return hashlib.sha1(data).hexdigest()


def _read_XO_value(path):
    return file(path).read().rstrip('\x00\n')
