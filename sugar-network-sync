#!/bin/sh

# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

debug() {
    [ "${V}" ] && echo "-- $@"
}

info() {
    echo "-- $@"
}

warning() {
    echo "-- $@"
}

abort() {
    echo "-- ERROR $@"
    exit 1
}

help() {
    cat <<EOF
Usage: $(basename $0) [PATH] [URL]

Sugar Network sneakernet synchronization utility.

Arguments:
  PATH      if specified, utility will try to recursive search for
            synchronization packet files (files with ".packet" suffix);
            using wget or curl utility, each packet will be uploaded
            to the targeting Sugar Network server with downloading resulting
            packets; on success, uploaded packets will be removed and resulting
            packets will be placed to PATH instead
  URL       if specified, should be Sugar Network API url, e.g.,
            http://api-testing.network.sugarlabs.org; script will download
            full data dump from the server

See http://wiki.sugarlabs.org/go/Sugar_Network for details.
EOF
}

get_header_key() {
    packet="$1"
    key="$2"

    tar -xf "${packet}" header --to-stdout | \
        grep -o "\"${key}\": *\"[^\"]*\"" | \
        awk -F\" '{print $4}'
}

upload() {
    in_packet="$1"
    cmd="$2"
    api_url="$3"
    if [ -z "${api_url}" ]; then
        api_url="$(get_header_key "${in_packet}" api_url)"
        if [ -z "${api_url}" ]; then
            info "Packet '${in_packet}' is not intended to upload to server, skipped"
            return 1
        fi
    fi
    url="${api_url}?cmd=${cmd}"
    out_packet="${in_packet}.out"

    info "Upload '${in_packet}'"
    [ -e "${out_packet}" ] && abort "Destination ${out_packet} already exists"

    if which wget >/dev/null 2>&1; then
        cmd="wget --post-file '${in_packet}' '${url}' -O '${out_packet}'"
        [ "${V}" ] || cmd="${cmd} -q"
    else
        cmd="curl -XPOST --data-binary @'${in_packet}' '${url}' -o '${out_packet}'"
        [ "${V}" ] || cmd="${cmd} -s"
    fi

    debug "Run '${cmd}' upload command"
    sh -c "$cmd" || abort "Cannot upload using '$cmd' command"

    if [ -e "${out_packet}" ]; then
        if [ $(stat -c %s "${out_packet}") -eq 0 ]; then
            rm "${out_packet}"
        else
            if [ "$(get_header_key "${out_packet}" continue)" = "true" ]; then
                tar xf "${out_packet}" continue || abort "Cannot exatract 'continue' file"
                tar uf continue.packet continue || abort "Cannot update 'continue.packet'"
                rm continue
            fi
            [ "$(get_header_key "${out_packet}" empty)" = "true" ] && rm "${out_packet}"
        fi
    fi

    info "Remove uploaded '${in_packet}' packet"
    rm "${in_packet}"

    if [ -e "${out_packet}" ]; then
        out_filename="$(get_header_key "${out_packet}" filename)"
        [ "${out_filename}" ] || out_filename="${in_packet}"
        info "Store resulting packet in '${out_filename}'"
        mv "${out_packet}" "${out_filename}" || abort
    fi
}

if [ $# -eq 0 ]; then
    help
    exit 0
fi

sync_path="$1"
clone_url="$2"
FS=

cd "${sync_path}" || abort "Cannot cd to '${sync_path}' sync directory"

# Push packet and collect "continue.packet" to pull afterwards
for packet in $(find . -name '*.packet' -a ! -name 'continue.packet'); do
    upload "${packet}" pull || continue
done

if [ "${clone_url}" ]; then
    info "Clone initial server dump from ${clone_url}"
    in_packet="clone.packet"
    [ -e ${in_packet} ] && abort "Destination ${in_packet} already exists"
    touch ${in_packet}
    upload ${in_packet} pull "${clone_url}"
fi
