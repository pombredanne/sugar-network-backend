#!/bin/sh

# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

debug() {
    [ "${V}" ] && echo "-- $@"
}

info() {
    echo "-- $@"
}

warning() {
    echo "-- $@"
}

abort() {
    echo "-- ERROR $@"
    exit 1
}

help() {
    cat <<EOF
Usage: $(basename $0) [PATH]

Sugar Network sneakernet synchronization utility.

If PATH is specified, utility will try to recursive search for synchronization
packet files (files with ".packet" suffix). Using wget or curl utility, each
packet will be uploaded to the targeting Sugar Network server with downloading
resulting packets. On success, uploaded packets will be removed and resulting
packets will be placed to PATH instead.

See http://wiki.sugarlabs.org/go/Sugar_Network for details.
EOF
}

get_header_key() {
    packet="$1"
    key="$2"

    tar -xf "${packet}" header --to-stdout | \
        grep -o "\"${key}\": *\"[^\"]*\"" | \
        awk -F\" '{print $4}'
}

upload() {
    in_packet="$1"
    cmd="$2"
    dst="$3"
    if [ "${dst}" ]; then
        [ -e "${in_packet}" ] && abort "Destination ${in_packet} already exists"
        touch "${in_packet}"
    else
        dst="$(get_header_key "${in_packet}" dst)"
        if [ -z "${dst}" ]; then
            info "Packet '${in_packet}' is not intended to upload to server, skipped"
            return 1
        fi
    fi
    url="${dst}?cmd=${cmd}"
    out_packet="${in_packet}.out"

    info "Upload ${in_packet}"
    [ -e "${out_packet}" ] && abort "Destination ${out_packet} already exists"

    if which wget >/dev/null 2>&1; then
        cmd="wget --post-file '${in_packet}' '${url}' -O '${out_packet}'"
        [ "${V}" ] || cmd="${cmd} -q"
    else
        cmd="curl -XPOST --data-binary @'${in_packet}' '${url}' -o '${out_packet}'"
        [ "${V}" ] || cmd="${cmd} -s"
    fi

    debug "Run '${cmd}' upload command"
    sh -c "$cmd" || abort "Cannot upload using '$cmd' command"

    if [ -e "${out_packet}" ]; then
        if [ $(stat -c %s "${out_packet}") -eq 0 ]; then
            rm "${out_packet}"
        else
            if [ "$(get_header_key "${out_packet}" continue)" = "true" ]; then
                tar xf "${out_packet}" continue || abort "Cannot exatract 'continue' file"
                tar uf continue.packet continue || abort "Cannot update 'continue.packet'"
                rm continue
            fi
            [ "$(get_header_key "${out_packet}" empty)" = "true" ] && rm "${out_packet}"
        fi
    fi

    if [ -e "${out_packet}" ]; then
        info "Replace '${in_packet}' packet by server response"
        mv "${out_packet}" "${in_packet}" || abort
    else
        info "Remove uploaded '${in_packet}' packet"
        rm "${in_packet}"
    fi
}

if [ $# -eq 0 ]; then
    help
    exit 0
fi

sync_path="$1"
FS=

cd "${sync_path}" || abort "Cannot cd to '${sync_path}' sync directory"

# Push packet and collect "continue.packet" to pull afterwards
for packet in $(find . -name '*.packet' -a ! -name 'continue.packet'); do
    upload "${packet}" pull || continue
    found=1
done

if [ -z "${found}" ]; then
    if [ -z "$2" ]; then
        info "No packets found in '${sync_path}', pass API url to fetch initial server dump"
    else
        info "No packets found in '${sync_path}', will clone initial server dump"
        upload clone.packet pull "$2"
    fi
else
    echo
fi
