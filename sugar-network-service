#!/usr/bin/env python

# Copyright (C) 2012, Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import logging
from os.path import join, abspath
from gettext import gettext as _

import active_document as ad
import restful_document as rd
import sugar_network_server as server
import sugar_network_webui as webui

from local_document import application, sugar, env, bus, activities
from local_document.mounts import Mounts
from sugar_network import bus as client
from active_toolkit import optparse, coroutine, enforce


VERSION = '0.2'

SUGAR_REGISTRATION_TIMEOUT = 5


class NullHandler(logging.Handler):

    def emit(self, record):
        pass


class Application(application.Daemon):

    _prefix = ''
    _home_volume = None
    _mounts = None
    _ipc_server = None
    _api_server = None
    _api_subscriber = None
    _web_server = None
    _monitor = None
    _reindexer = None

    def __init__(self, **kwargs):
        application.Daemon.__init__(self, **kwargs)

        # Disable some low level logging
        for log_name in (
                'requests.packages.urllib3.connectionpool',
                'requests.packages.urllib3.poolmanager',
                'requests.packages.urllib3.response',
                'requests.packages.urllib3',
                'inotify',
                ):
            logger = logging.getLogger(log_name)
            logger.propagate = False
            logger.addHandler(NullHandler())

        new_root = (env.local_root.value != env.local_root.default)
        env.local_root.value = abspath(env.local_root.value)
        env.activities_root.value = abspath(env.activities_root.value)

        if new_root:
            application.logdir.value = join(env.local_root.value, 'log')
        else:
            application.logdir.value = sugar.profile_path('logs')
        application.rundir.value = join(env.local_root.value, 'run')

    @application.command(
            _('[PREFIX-PATH SYSTEM-USER USER-GUID]\n'
                'Index local Sugar Network database'))
    def index(self):
        enforce(not self.args or len(self.args) == 3,
                _('Not all command arguments where specified'))

        if self.args:
            prefix, user, uid = self.args
            self._prefix = abspath(prefix)
            if env.activities_root.value == env.activities_root.default:
                env.activities_root.value = join(self._prefix, 'home', user,
                        'Activities')
            if env.local_root.value == env.local_root.default:
                env.local_root.value = join(self._prefix, 'home', user,
                        '.sugar', 'default', 'network')
            sugar.uid = lambda: uid

        ad.index_lazy_open.value = False
        try:
            self._mount(False)
            self._populate_index()
            activities.populate(self._mounts, self._activity_directories,
                    self._prefix)
        finally:
            self._mounts.close()

    def run(self):
        while not sugar.has_pubkey():
            logging.info(_('No Sugar SSH key, delay start for %s seconds'),
                    SUGAR_REGISTRATION_TIMEOUT)
            coroutine.sleep(SUGAR_REGISTRATION_TIMEOUT)

        self._mount(env.server_mode.value)

        if env.delayed_start.value:
            delayed_start = self._delayed_start
        else:
            self._delayed_start()
            delayed_start = None

        self._ipc_server = bus.Server(self._mounts, delayed_start)
        self._mounts.connect(self._ipc_server.publish)

        if env.server_mode.value:
            logging.info(_('Listening for remote requests on %s port'),
                    server.port.value)
            self._api_server = coroutine.WSGIServer(
                    ('0.0.0.0', server.port.value),
                    rd.Router(self._mounts['~']))
            coroutine.spawn(self._api_server.serve_forever)
            self._api_subscriber = rd.SubscribeSocket(self._home_volume,
                    '0.0.0.0', server.subscribe_port.value)
            coroutine.spawn(self._api_subscriber.serve_forever)

        try:
            self._ipc_server.serve_forever()
        finally:
            if self._reindexer is not None:
                self._reindexer.kill()
            if self._monitor is not None:
                self._monitor.kill()
            if self._web_server is not None:
                self._web_server.stop()
            if self._api_server is not None:
                self._api_server.stop()
            if self._api_subscriber is not None:
                self._api_subscriber.stop()
            self._mounts.close()

    def shutdown(self):
        if self._ipc_server is not None:
            self._ipc_server.stop()

    @property
    def _db_path(self):
        return join(env.local_root.value, 'local')

    @property
    def _activity_directories(self):
        return [env.activities_root.value,
                self._prefix + '/usr/share/sugar/activities',
                self._prefix + '/opt/sweets']

    def _delayed_start(self):
        logging.info(_('Proceed delayed start'))

        self._reindexer = coroutine.spawn(self._populate_index)

        self._monitor = coroutine.spawn(activities.monitor, self._home_volume,
                self._activity_directories)

        if webui.webui.value:
            # Point client API to `self._mounts` directly passing over IPC
            client.Request.connection = self._mounts
            host = (webui.webui_host.value, webui.webui_port.value)
            logging.info(_('Start Web server on %s:%s port'), *host)
            self._web_server = coroutine.WSGIServer(host, webui.get_app())
            coroutine.spawn(self._web_server.serve_forever)

    def _mount(self, server_mode):
        if server_mode:
            documents = server.documents()
        else:
            documents = server.documents(['context', 'report'])
        self._home_volume = ad.SingleVolume(self._db_path, documents)
        server.volume.update(self._home_volume)
        self._mounts = Mounts(self._home_volume)

    def _populate_index(self):
        for cls in self._home_volume.values():
            for __ in cls.populate():
                coroutine.dispatch()


# New defaults
application.debug.value = sugar.logger_level()
rd.only_sync_notification.value = False
ad.index_lazy_open.value = True
webui.webui.value = True
# It seems to be that most of users (on XO at least) don't have recent SSH
server.trust_users.value = True

optparse.Option.seek('main', [application.debug, application.foreground])
optparse.Option.seek('webui', webui)
optparse.Option.seek('sugar-network', env)
optparse.Option.seek('sugar-network-server',
        [server.port, server.subscribe_port])
optparse.Option.seek('restful-document', rd)
optparse.Option.seek('active-document', ad)

application = Application(
        name='sugar-network-service',
        description=_('Sugar Network service'),
        epilog=_('See http://wiki.sugarlabs.org/go/Sugar_Network ' \
                 'for details.'),
        version=VERSION,
        config_files=[
            '/etc/sweets.conf',
            '~/.config/sweets/config',
            sugar.profile_path('sweets.conf'),
            ])
application.start()
