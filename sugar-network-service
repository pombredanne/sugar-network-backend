#!/usr/bin/env python

# Copyright (C) 2012, Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import logging
from os.path import join, abspath
from gettext import gettext as _

import active_document as ad
import restful_document as rd
import sugar_network_server as server
from sugar_network_server import resources
from local_document import application, sugar, env, bus, activities
from local_document.mounts import Mounts
from active_toolkit import optparse, coroutine


VERSION = '0.2'

SUGAR_REGISTRATION_TIMEOUT = 5


class Application(application.Daemon):

    _bus = None

    def start(self):
        new_root = (env.local_root.value != env.local_root.default)
        env.local_root.value = abspath(env.local_root.value)
        env.activities_root.value = abspath(env.activities_root.value)

        if new_root:
            application.logdir.value = join(env.local_root.value, 'log')
        else:
            application.logdir.value = sugar.profile_path('logs')
        application.rundir.value = join(env.local_root.value, 'run')

        application.Daemon.start(self)

    def run(self):
        while not sugar.has_pubkey():
            logging.info(_('No Sugar SSH key, will start in %s seconds'),
                    SUGAR_REGISTRATION_TIMEOUT)
            coroutine.sleep(SUGAR_REGISTRATION_TIMEOUT)

        mounts = Mounts(join(env.local_root.value, 'local'), resources.path,
                lambda event: self._bus.emit(event))
        self._bus = bus.Server(mounts)
        monitor = coroutine.spawn(activities.monitor, mounts, [
            env.activities_root.value,
            '/usr/share/sugar/activities',
            '/opt/sweets',
            ])
        http_server = None
        http_subscriber = None

        if env.server_mode.value:
            logging.info(_('Listening for remote requests on %s port'),
                    server.port.value)
            http_server = coroutine.WSGIServer(('0.0.0.0', server.port.value),
                    rd.Router(mounts['~']))
            coroutine.spawn(http_server.serve_forever)
            http_subscriber = rd.SubscribeSocket(mounts.home_volume,
                    '0.0.0.0', server.subscribe_port.value)
            coroutine.spawn(http_subscriber.serve_forever)

        try:
            self._bus.serve_forever()
        finally:
            monitor.kill()
            if http_server is not None:
                http_server.stop()
            if http_subscriber is not None:
                http_subscriber.stop()
            mounts.close()

    def shutdown(self):
        if self._bus is not None:
            self._bus.stop()


# New defaults
application.debug.value = sugar.logger_level()
rd.only_sync_notification.value = False
# It seems to be that most of users (on XO at least) don't have recent SSH
server.trust_users.value = True

optparse.Option.seek('main', [application.debug, application.foreground])
optparse.Option.seek('sugar-network', env)
optparse.Option.seek('sugar-network-server',
        [server.port, server.subscribe_port])
optparse.Option.seek('restful-document', rd)
optparse.Option.seek('active-document', ad)

app = Application(
        name='sugar-network-service',
        description=_('Sugar Network service'),
        epilog=_('See http://wiki.sugarlabs.org/go/Sugar_Network ' \
                 'for details.'),
        version=VERSION,
        config_files=[
            '/etc/sweets.conf',
            '~/.config/sweets/config',
            sugar.profile_path('sweets.conf'),
            ])
app.start()
