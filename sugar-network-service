#!/usr/bin/env python

# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import locale
import logging
from contextlib import contextmanager
from os.path import join, abspath, exists
from gettext import gettext as _

import active_document as ad
import sugar_network_webui as webui

from sugar_network import local, node, Client
from sugar_network.toolkit import application, sugar, printf, sneakernet, ipc
from sugar_network.local import activities
from sugar_network.local.bus import IPCServer
from sugar_network.local.mounts import HomeMount, RemoteMount
from sugar_network.local.mountset import Mountset
from sugar_network.resources.volume import Volume
from active_toolkit import optparse, coroutine, enforce


VERSION = '0.4'


class NullHandler(logging.Handler):

    def emit(self, record):
        pass


class Application(application.Daemon):

    _mountset = None
    _ipc_server = None
    _events = {}

    def __init__(self, **kwargs):
        application.Daemon.__init__(self, **kwargs)

        if application.debug.value < 3:
            for log_name in (
                    'requests.packages.urllib3.connectionpool',
                    'requests.packages.urllib3.poolmanager',
                    'requests.packages.urllib3.response',
                    'requests.packages.urllib3',
                    'inotify',
                    'netlink',
                    'sneakernet',
                    ):
                logger = logging.getLogger(log_name)
                logger.propagate = False
                logger.addHandler(NullHandler())

        new_root = (local.local_root.value != local.local_root.default)
        local.local_root.value = abspath(local.local_root.value)
        local.mounts_root.value = abspath(local.mounts_root.value)

        if new_root:
            application.logdir.value = join(local.local_root.value, 'log')
        else:
            application.logdir.value = sugar.profile_path('logs')
        application.rundir.value = join(local.local_root.value, 'run')

        sneakernet.TMPDIR = local.tmpdir.value

    @application.command(
            _('[PREFIX-PATH] [USER-GUID]\n'
                'Index local Sugar Network database'))
    def index(self):
        if ipc.server_exists():
            printf.info(_('%s already started, no need in index'), self.name)
            return

        root = ''
        if self.args:
            root = abspath(self.args.pop(0))
            local.activity_dirs.value = [root + abspath(i) \
                    for i in local.activity_dirs.value]
            local.local_root.value = root + local.local_root.value

        if self.args:
            user = self.args.pop(0)
            sugar.uid = lambda: user
            sugar.nickname = lambda: user

        printf.info(_('Index database in %r'), local.local_root.value)

        volume = Volume(self._db_path)
        try:
            volume.populate()
            activities.populate(volume, local.activity_dirs.value, root)
        finally:
            volume.close()

    @application.command(
            _('[PATH]\n'
                'start sneakernet synchronization; if PATH is specified, '
                'use it as a synchronization directory; otherwise, '
                'look for mounts (in --mounts-root) that contain '
                'sugar-network-sync/ subdirectory'))
    def offline_sync(self):
        with self._rendezvous():
            path = None
            if self.args:
                path = self.args.pop(0)
            Client.call('POST', cmd='start_sync', rewind=True, path=path)
            self._events['sync_complete'].wait()

    def run(self, local_run=False):
        volume = Volume(self._db_path, lazy_open=local.lazy_open.value)
        self._mountset = Mountset(volume)
        self._mountset['~'] = HomeMount(volume)
        self._mountset['/'] = RemoteMount(volume)
        servers = coroutine.ServersPool()
        jobs = coroutine.Pool()

        if local_run or webui.webui.value:
            # Point clients to `self._mountset` directly passing over IPC
            Client.connection = self._mountset

        def delayed_start():
            logging.info(_('Proceed delayed start'))

            jobs.spawn(activities.monitor, volume, local.activity_dirs.value)
            jobs.spawn(volume.populate)

            if webui.webui.value:
                host = (webui.webui_host.value, webui.webui_port.value)
                logging.info(_('Start Web server on %s:%s'), *host)
                servers.spawn(coroutine.WSGIServer, host, webui.get_app())

        if local.delayed_start.value:
            delayed_start_cb = delayed_start
        else:
            delayed_start()
            delayed_start_cb = None

        self._ipc_server = IPCServer(self._mountset, delayed_start_cb)
        try:
            self._mountset.open()
            self._ipc_server.serve_forever()
        finally:
            servers.stop()
            jobs.kill()
            self._mountset.close()

    def shutdown(self):
        if self._ipc_server is not None:
            self._ipc_server.stop()

    @contextmanager
    def _rendezvous(self):

        def events_cb(event):
            if event['event'] == 'sync_start':
                printf.info(_('Synchronize with %(path)s directory') % event)
            elif event['event'] == 'sync_progress':
                printf.progress(event['progress'])
            elif event['event'] == 'sync_continue':
                printf.info(_('Mounted synchronization disk(s) is full, ' \
                        'mount new one to %s'), local.mounts_root.value)
            elif event['event'] == 'sync_error':
                printf.info(_('Failed to sync, %(error)s') % event)
            elif event['event'] == 'sync_complete':
                self._events['sync_complete'].set()

        self._events['sync_complete'] = coroutine.Event()

        server = None
        try:
            if not ipc.server_exists():
                printf.info(_('%s is not started, ' \
                        'launch it for this command only'), self.name)
                server = coroutine.spawn(self.run, True)
                coroutine.dispatch()
                self._mountset.opened.wait()

            Client.connect(events_cb)
            yield

        finally:
            if server is not None:
                server.kill()

    @property
    def _db_path(self):
        return join(local.local_root.value, 'local')


locale.setlocale(locale.LC_ALL, '')

# New defaults
application.debug.value = sugar.logger_level()
# It seems to be that most of users (on XO at least) don't have recent SSH
node.trust_users.value = True

optparse.Option.seek('main', [application.debug, application.foreground])
optparse.Option.seek('webui', webui)
optparse.Option.seek('local', local)
optparse.Option.seek('node', [node.port, node.subscribe_port])
optparse.Option.seek('active-document', ad)

application = Application(
        name='sugar-network-service',
        description=_('Sugar Network service.'),
        epilog=_('See http://wiki.sugarlabs.org/go/Sugar_Network ' \
                 'for details.'),
        version=VERSION,
        config_files=[
            '/etc/sweets.conf',
            '~/.config/sweets/config',
            sugar.profile_path('sweets.conf'),
            ])
application.start()
