#!/usr/bin/env python

# Copyright (C) 2012-2013 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import locale
import gettext
import logging
from os.path import exists, join

from gevent import monkey

from sugar_network import db, node, client, toolkit, model
from sugar_network.node import stats_user, obs, master, slave
from sugar_network.node import model as master_model
from sugar_network.node.routes import generate_node_stats
from sugar_network.toolkit.http import Connection
from sugar_network.toolkit.router import Router, Request, Response
from sugar_network.toolkit import coroutine, application, Option, enforce


gettext.textdomain('sugar-network')


class Application(application.Daemon):

    jobs = coroutine.Pool()
    node = None

    def ensure_run(self):
        if toolkit.cachedir.value and not exists(toolkit.cachedir.value):
            os.makedirs(toolkit.cachedir.value)
        if not exists(node.data_root.value):
            os.makedirs(node.data_root.value)
        enforce(os.access(node.data_root.value, os.W_OK),
                'No write access to %r directory', node.data_root.value)

    def run(self):
        ssl_args = {}
        if node.keyfile.value:
            ssl_args['keyfile'] = node.keyfile.value
        if node.certfile.value:
            ssl_args['certfile'] = node.certfile.value

        master_path = join(node.data_root.value, 'master')
        if exists(master_path):
            with file(master_path) as f:
                node_key = f.read().strip()
            node_class = master.MasterRoutes
            resources = master_model.RESOURCES
            logging.info('Start %s node in master mode', node_key)
        else:
            node_key = join(node.data_root.value, 'node.key')
            node_class = slave.SlaveRoutes
            resources = model.RESOURCES
            logging.info('Start slave node')
        volume = db.Volume(node.data_root.value, resources)
        cp = node_class(node_key, volume, find_limit=node.find_limit.value)
        self.jobs.spawn(volume.populate)

        logging.info('Listening for requests on %s:%s',
                node.host.value, node.port.value)
        server = coroutine.WSGIServer((node.host.value, node.port.value),
                Router(cp), **ssl_args)
        self.jobs.spawn(server.serve_forever)
        self.accept()

        try:
            self.jobs.join()
        finally:
            cp.close()
            volume.close()

    def shutdown(self):
        self.jobs.kill()

    @application.command(
            'direct synchronization with master node',
            name='online-sync')
    def online_sync(self):
        self._ensure_instance().post(cmd='online-sync')

    @application.command(
            'sneakernet synchronization with other nodes using files '
            'placed to the specified directory',
            args='PATH', name='offline-sync')
    def offline_sync(self):
        enforce(self.args, 'PATH was not specified')
        path = self.args.pop(0)
        self._ensure_instance().post(cmd='offline-sync', path=path)

    @application.command(
            're-generate node statistics', name='restat')
    def restat(self):
        enforce(not self.check_for_instance(), 'Shutdown the server at first')
        volume = db.Volume(node.data_root.value, model.RESOURCES)
        volume.populate()
        generate_node_stats(volume, join(node.stats_root.value, 'node'))

    def _ensure_instance(self):
        enforce(self.check_for_instance(), 'Node is not started')
        return Connection('http://localhost:%s' %
                node.port.value, trust_env=False)


# Let toolkit.http work in concurrence
monkey.patch_socket()
monkey.patch_select()
monkey.patch_ssl()
monkey.patch_time()

locale.setlocale(locale.LC_ALL, '')

Option.seek('main', application)
Option.seek('main', [toolkit.cachedir])
Option.seek('client', [client.api_url])
Option.seek('node', node)
Option.seek('user-stats', stats_user)
Option.seek('obs', obs)
Option.seek('db', db)

app = Application(
        name='sugar-network-node',
        description='Sugar Network node server',
        epilog='See http://wiki.sugarlabs.org/go/Sugar_Network '
               'for details.',
        config_files=[
            '/etc/sugar-network.d',
            '/etc/sugar-network.conf',
            '~/.config/sugar-network/config',
            ])
app.start()
