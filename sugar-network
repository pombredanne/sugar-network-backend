#!/usr/bin/env python

# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import sys
import shlex
import types
import locale
from json import dumps, loads
from os.path import join, exists, isfile

from gevent import monkey

from sugar_network import db, client, toolkit
from sugar_network.model import RESOURCES
from sugar_network.client import IPCConnection, Connection
from sugar_network.client.routes import ClientRoutes
from sugar_network.toolkit.router import Router, Request, Response
from sugar_network.toolkit import application, coroutine
from sugar_network.toolkit import Option, BUFFER_SIZE, enforce


porcelain = Option(
        'give the output in an easy-to-parse format for scripts',
        default=False, type_cast=Option.bool_cast, action='store_true',
        name='porcelain')

post_data = Option(
        'send content as a string from POST or PUT command',
        name='post_data', short_option='-d')

post_file = Option(
        'send content of the specified file from POST or PUT command',
        name='post_file', short_option='-f')

json = Option(
        'treat POST or PUT command content as a JSON data',
        name='json', short_option='-j', default=False,
        type_cast=Option.bool_cast, action='store_true')

offline = Option(
        'do not connect to Sugar Network server',
        default=False, type_cast=Option.bool_cast, action='store_true',
        name='offline')


_ESCAPE_VALUE_RE = re.compile(r'([^\[\]\{\}0-9][^\]\[\{\}]+)')
_LIST_RE = re.compile(r'\s*[;,:]+\s*')


class ClientRouter(ClientRoutes, Router):

    def __init__(self):
        home = db.Volume(client.path('db'), RESOURCES)
        ClientRoutes.__init__(self, home,
                client.api_url.value if not offline.value else None,
                no_subscription=True)
        Router.__init__(self, self)

        if not offline.value:
            for __ in self.subscribe(event='inline', state='online'):
                break
            coroutine.dispatch()
        server = coroutine.WSGIServer(
                ('localhost', client.ipc_port.value), self)
        coroutine.spawn(server.serve_forever)
        coroutine.dispatch()


class Application(application.Application):

    def __init__(self, **kwargs):
        application.Application.__init__(self, **kwargs)

        application.rundir.value = join(client.local_root.value, 'run')
        toolkit.init_logging(application.debug.value)

        if not exists(toolkit.cachedir.value):
            os.makedirs(toolkit.cachedir.value)

    @application.command(
            'launch a Sugar activity; the COMMAND-LINE-ARGUMENTS might '
            'include arguments supported by sugar-activity application',
            args='BUNDLE_ID [COMMAND-LINE-ARGUMENTS]',
            interspersed_args=False,
            )
    def launch(self):
        enforce(self.check_for_instance(), 'No sugar-network-client session')
        ipc = IPCConnection()

        enforce(self.args, 'BUNDLE_ID was not specified')
        bundle_id = self.args.pop(0)

        params = {}
        if self.args:
            params['args'] = self.args

        ipc.get(['context', bundle_id], cmd='launch', **params)

    @application.command(
            'clone Sugar activities to ~/Activities directory',
            args='BUNDLE_ID',
            )
    def clone(self):
        enforce(self.check_for_instance(), 'No sugar-network-client session')
        ipc = IPCConnection()

        enforce(self.args, 'BUNDLE_ID was not specified')
        bundle_id = self.args.pop(0)

        ipc.put(['context', bundle_id], 1, cmd='clone')

    @application.command(
            'upload new implementaion for a context; if BUNDLE_PATH points '
            'not to a .xo bundle, specify all implementaion PROPERTYs for the '
            'new release (at least context and version)',
            args='BUNDLE_PATH [PROPERTY=VALUE]',
            )
    def release(self):
        enforce(self.args, 'BUNDLE_PATH was not specified')
        path = self.args.pop(0)
        enforce(isfile(path), 'Cannot open bundle')

        props = {'tags': []}
        self._parse_args(props['tags'], props)
        if 'license' in props:
            value = [i for i in _LIST_RE.split(props['license'].strip()) if i]
            props['license'] = value

        guid = self._connect().upload(['implementation'], path, cmd='release')

        if porcelain.value:
            print 'Uploaded new release, %s' % guid
        else:
            print dumps(guid)

    @application.command(
            'send raw API POST request; '
            'specifies all ARGUMENTs the particular API call requires',
            args='PATH [ARGUMENT=VALUE]')
    def post(self):
        self._request('POST', True)

    @application.command(hidden=True)
    def POST(self):
        self.post()

    @application.command(
            'send raw API PUT request; '
            'specifies all ARGUMENTs the particular API call requires',
            args='PATH [ARGUMENT=VALUE]')
    def put(self):
        self._request('PUT', True)

    @application.command(hidden=True)
    def PUT(self):
        self.put()

    @application.command(
            'send raw API DELETE request',
            args='PATH')
    def delete(self):
        self._request('DELETE', False)

    @application.command(hidden=True)
    def DELETE(self):
        self.delete()

    @application.command(
            'send raw API GET request; '
            'specifies all ARGUMENTs the particular API call requires',
            args='PATH [ARGUMENT=VALUE]')
    def get(self):
        self._request('GET', False)

    @application.command(hidden=True)
    def GET(self):
        self.get()

    @application.command(
            'send raw API HEAD request; '
            'specifies all ARGUMENTs the particular API call requires',
            args='PATH [ARGUMENT=VALUE]')
    def head(self):
        request = Request()
        self._parse_path(request)
        self._parse_args([], request)
        result = self._connect().meta(request.path, **request)
        self._dump(result, [])

    @application.command(hidden=True)
    def HEAD(self):
        self.head()

    def _connect(self):
        if self.check_for_instance():
            return IPCConnection()
        else:
            return Connection(client.api_url.value)

    def _request(self, method, post):
        request = Request(method=method)
        request.allow_redirects = True
        request.accept_encoding = ''
        response = Response()

        if post:
            if post_data.value is None and post_file.value is None:
                json.value = True
                post_data.value = sys.stdin.read()

            if post_data.value:
                request.content = post_data.value.strip()
            elif post_file.value:
                with file(post_file.value, 'rb') as f:
                    # TODO Avoid loading entire file
                    request.content = f.read()

            request.content_type = 'application/octet-stream'
            if json.value:
                try:
                    request.content = loads(request.content)
                    request.content_type = 'application/json'
                except Exception:
                    # TODO
                    pass

        self._parse_path(request)
        reply = []
        self._parse_args(reply, request)

        pid_path = None
        server = None
        cp = None
        try:
            if self.check_for_instance():
                cp = IPCConnection()
            else:
                pid_path = self.new_instance()
                if not client.anonymous.value:
                    toolkit.ensure_key(client.key_path())
                cp = ClientRouter()
            result = cp.call(request, response)
        finally:
            if server is not None:
                server.close()
            if cp is not None:
                cp.close()
            if pid_path:
                os.unlink(pid_path)

        if result is None:
            return

        if response.content_type == 'application/json':
            self._dump(result, reply)
        elif response.content_type == 'text/event-stream':
            while True:
                chunk = toolkit.readline(result)
                if not chunk:
                    break
                sys.stdout.write(chunk)
        elif hasattr(result, 'read'):
            while True:
                chunk = result.read(BUFFER_SIZE)
                if not chunk:
                    break
                sys.stdout.write(chunk)
        elif isinstance(result, types.GeneratorType):
            for chunk in result:
                sys.stdout.write(chunk)
        else:
            sys.stdout.write(result)

    def _parse_path(self, request):
        if self.args and self.args[0].startswith('/'):
            request.path = self.args.pop(0).strip('/').split('/')

    def _parse_args(self, tags, props):
        for arg in self.args:
            arg = shlex.split(arg)
            if not arg:
                continue
            arg = arg[0]
            if '=' not in arg:
                tags.append(arg)
                continue
            arg, value = arg.split('=', 1)
            arg = arg.strip()
            enforce(arg, 'No argument name in %r expression', arg)
            if arg in props:
                if isinstance(props[arg], basestring):
                    props[arg] = [props[arg]]
                props[arg].append(value)
            else:
                props[arg] = value

    def _dump(self, result, reply):
        if porcelain.value:
            if type(result) in (list, tuple):
                for i in result:
                    # TODO
                    print i
            else:
                # TODO
                print result
        elif reply:
            for key in reply:
                key = _ESCAPE_VALUE_RE.sub("'\\1'", key)
                print eval('result%s' % key)
        else:
            print dumps(result, indent=2, ensure_ascii=False)


# Let toolkit.http work in concurrence
monkey.patch_socket()
monkey.patch_select()
monkey.patch_ssl()
monkey.patch_time()

# New defaults
application.debug.value = client.logger_level()
# If tmpfs is mounted to /tmp, `os.fstat()` will return 0 free space
# and will brake offline synchronization logic
toolkit.cachedir.value = client.profile_path('tmp')

Option.seek('main', [
    application.debug, porcelain, post_data, post_file, json, offline,
    ])
Option.seek('client', [
    client.api_url, client.layers, client.ipc_port, client.local_root,
    client.no_dbus, client.anonymous, client.accept_language,
    ])

locale.setlocale(locale.LC_ALL, '')

app = Application(
        name='sugar-network-client',
        description='Sugar Network client utility',
        epilog='See http://wiki.sugarlabs.org/go/Sugar_Network '
               'for details.',
        config_files=[
            '/etc/sweets.d',
            '/etc/sweets.conf',
            '~/.config/sweets/config',
            client.profile_path('sweets.conf'),
            ],
        )
app.start()
