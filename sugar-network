#!/usr/bin/env python

# Copyright (C) 2012 Aleksey Lim
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import sys
import shlex
import locale
from json import dumps, loads
from os.path import join

from gevent import monkey

import active_document as ad
from sugar_network import client, sugar, toolkit, IPCClient
from sugar_network.toolkit.router import IPCRouter, Request
from sugar_network.resources.volume import Volume
from sugar_network.client.mountset import Mountset
from sugar_network.client.mounts import HomeMount, RemoteMount
from active_toolkit.options import Option
from active_toolkit.sockets import BUFFER_SIZE
from active_toolkit import printf, application, coroutine, enforce


anonymous = Option(
        'use anonymous user to access to Sugar Network server; '
        'only read-only operations are available in this mode',
        default=False, type_cast=Option.bool_cast, action='store_true',
        name='anonymous')

porcelain = Option(
        'give the output in an easy-to-parse format for scripts',
        default=False, type_cast=Option.bool_cast, action='store_true',
        name='porcelain')

post_data = Option(
        'send content as a string from POST or PUT command',
        name='post_data', short_option='-d')

post_file = Option(
        'send content of the specified file from POST or PUT command',
        name='post_file', short_option='-f')

json = Option(
        'treat POST or PUT command content as a JSON data',
        name='json', short_option='-j', default=False,
        type_cast=Option.bool_cast, action='store_true')


_ESCAPE_VALUE_RE = re.compile('([^\[\]\{\}0-9][^\]\[\{\}]+)')


class Application(application.Application):

    def __init__(self, **kwargs):
        application.Application.__init__(self, **kwargs)
        application.rundir.value = join(client.local_root.value, 'run')
        toolkit.init_logging(application.debug.value)

    @application.command(
            'send POST API request')
    def POST(self):
        self._call('POST', True)

    @application.command(
            'send PUT API request')
    def PUT(self):
        self._call('PUT', True)

    @application.command(
            'send DELETE API request')
    def DELETE(self):
        self._call('DELETE', False)

    @application.command(
            'send GET API request')
    def GET(self):
        self._call('GET', False)

    def _call(self, method, post):
        request = Request(method=method)
        request.allow_redirects = True
        response = ad.Response()
        reply = []

        if post:
            if post_data.value is None and post_file.value is None:
                json.value = True
                post_data.value = sys.stdin.read()

            if post_data.value:
                request.content = post_data.value.strip()
            elif post_file.value:
                with file(post_file.value, 'rb') as f:
                    # TODO Avoid loading entire file
                    request.content = f.read()

            request.content_type = 'application/octet-stream'
            if json.value:
                try:
                    request.content = loads(request.content)
                    request.content_type = 'application/json'
                except Exception:
                    # TODO
                    pass

        if self.args and self.args[0].startswith('/'):
            path = self.args.pop(0).strip('/').split('/')
            request['document'] = path.pop(0)
            if path:
                request['guid'] = path.pop(0)
            if path:
                request['prop'] = path.pop(0)

        for arg in self.args:
            arg = shlex.split(arg)
            if not arg:
                continue
            arg = arg[0]
            if '=' not in arg:
                reply.append(arg)
                continue
            arg, value = arg.split('=', 1)
            arg = arg.strip()
            enforce(arg, 'No argument name in %r expression', arg)
            if arg in request:
                if isinstance(request[arg], basestring):
                    request[arg] = [request[arg]]
                request[arg].append(value)
            else:
                request[arg] = value

        mountpoint = request.get('mountpoint')
        if mountpoint and mountpoint == os.environ['HOME']:
            # Convert back shell replacement for '~' symbol
            request['mountpoint'] = '~'

        pid_path = None
        server = None
        mountset = None
        try:
            if not self.check_for_instance():
                pid_path = self.new_instance()
                if anonymous.value:
                    sugar.uid = lambda: 'anonymous'
                    sugar.nickname = lambda: 'anonymous'
                    sugar.color = lambda: '#000000,#000000'
                    sugar.privkey_path = lambda: '/fake/path'
                else:
                    toolkit.ensure_dsa_pubkey(sugar.profile_path('owner.key'))
                volume = Volume(client.db_path())
                mountset = Mountset(volume)
                mountset['~'] = HomeMount(volume)
                if not mountpoint or mountpoint == '/':
                    mountset['/'] = RemoteMount(volume, listen_events=False)
                    mountset['/'].mounted.wait()
                server = coroutine.WSGIServer(
                        ('localhost', client.ipc_port.value),
                        IPCRouter(mountset))
                coroutine.spawn(server.serve_forever)
                coroutine.dispatch()

            result = IPCClient(sync=True).call(request, response)

        finally:
            if server is not None:
                server.close()
            if mountset is not None:
                mountset.close()
            if pid_path:
                os.unlink(pid_path)

        if result is None:
            return

        if response.content_type == 'application/json':
            if porcelain.value:
                if type(result) in (list, tuple):
                    for i in result:
                        # TODO
                        print i
                else:
                    # TODO
                    print result
            elif reply:
                for key in reply:
                    key = _ESCAPE_VALUE_RE.sub("'\\1'", key)
                    print eval('result%s' % key)
            else:
                print dumps(result, indent=2)
        elif hasattr(result, 'read'):
            while True:
                chunk = result.read(BUFFER_SIZE)
                if not chunk:
                    break
                sys.stdout.write(chunk)
        else:
            sys.stdout.write(result)

# Let toolkit.http work in concurrence
# XXX No DNS because `toolkit.network.res_init()` doesn't work otherwise
monkey.patch_socket(dns=False)
monkey.patch_select()
monkey.patch_ssl()
monkey.patch_time()

# New defaults
application.debug.value = sugar.logger_level()
Option.seek('main', [
    application.debug, anonymous, porcelain, post_data, post_file, json,
    ])
Option.seek('client', [
    client.api_url, client.layers, client.ipc_port, client.local_root,
    client.no_dbus,
    ])

locale.setlocale(locale.LC_ALL, '')

app = Application(
        name='sugar-network-client',
        description='Sugar Network client utility',
        epilog='See http://wiki.sugarlabs.org/go/Sugar_Network ' \
                 'for details.',
        config_files=[
            '/etc/sweets.conf',
            '~/.config/sweets/config',
            sugar.profile_path('sweets.conf'),
            ],
        stop_args=['launch'])
app.start()
